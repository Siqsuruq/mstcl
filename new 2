package require nx
package require tdom
package require fileutil

nx::Class create Mapfile {
	:property name:required
	:property path
	
	:method init {} {
		if {[info exists :path] != 0} {
			set :map_file [file join ${:path} ${:name}]
		} else {
			set :path ./
			set :map_file [file join ${:path} ${:name}]
		}
		
		set :keywds [dict create Map MAP name NAME end END Layer LAYER Class CLASS Style STYLE angle ANGLE shapePath SHAPEPATH data DATA extent EXTENT size SIZE imageType IMAGETYPE imageColor IMAGECOLOR color COLOR status STATUS\
		type TYPE OutputFormat OUTPUTFORMAT mimeType MIMETYPE driver DRIVER extension EXTENSION imageMode IMAGEMODE transparent TRANSPARENT resolution RESOLUTION defResolution DEFRESOLUTION fontSet FONTSET symbolSet SYMBOLSET\
		units UNITS projection PROJECTION Legend LEGEND keySize KEYSIZE keySpacing KEYSPACING Label LABEL offset OFFSET shadowSize SHADOWSIZE QueryMap QUERYMAP ScaleBar SCALEBAR intervals INTERVALS Web WEB Metadata METADATA\
		outlineColor OUTLINECOLOR template TEMPLATE]
		
		# Get file extension, create working copy (temporary file), empty dom in memory, initial stack
		set fext [file extension ${:map_file}]
		dom createDocumentNode :doc
		set :stack ""
		set :tmp_mf [::fileutil::tempfile]

		# File exists and has .map extention
		if {[file exists ${:map_file}] != 0 || $fext eq ".map"} {
			set fp [open ${:tmp_mf} a+]
			puts $fp [: -local strip_comments] ;# Remove coments from .map file and write it to temp file tmp_mf
			close $fp
			: -local map2xml
		} else {
			# puts "EMPTY ${:tmp_mf}"
		}
	}

	:public method "save" {ftype fname} {
		if {$ftype eq "xml"} {
			puts "Saving file to: [file join ${:path} ${:name}]"
		} elseif {$ftype eq "map"} {
			puts "Saving file to: [file join ${:path} ${:name}]"
		}
	}
	
	:public method "map2xml" {} {
		if {[file exists ${:tmp_mf}] != 0} {
			set fp [open "${:tmp_mf}" r]
			set file_data [read $fp]
			close $fp
			set data [split $file_data "\n"]
			foreach line $data {
				if {$line ne ""} {
					: -local line $line
				}
			}
		} else {return "File doesnt exists."}
	}
	
	:public method "strip_comments" {} {
		set commentChars "#"
		set stripped ""
		set fp [open "${:map_file}" r]
		set file_data [read $fp]
		close $fp
		set data [split $file_data "\n"]
		foreach line $data {
			regsub -all -line "\[$commentChars\].*$" $line "" commentStripped
			regsub "^\[ \t]*$" $commentStripped {} fline
			if {$fline ne ""} {
				append stripped "" $fline\n
			}
		}
		return $stripped
	}
	
	:public method "list_layers" {args} {
		if {[${:doc} hasChildNodes]} {
			set layers_dict [dict create]
			set count 1
			set layers [${:doc} getElementsByTagName Layer]
			foreach lay $layers {
				set line [dict create]
				set attrs [$lay attributeNames]
				foreach attr $attrs {
					dict append line $attr [$lay getAttribute $attr]
				}
				dict append layers_dict Layer$count $line
				incr count
			}
			return $layers_dict
		} else {
			: -local map2xml
			: -local list_layers
		}
	}
	
	:public method "print_stack" {args} {
		puts "CURRENT STACK: ${:stack}"
	}
	

	# Private classes defenition
	
	:public method "line" {line} {
		set keywords [dict values ${:keywds}]
		set kw ""
		foreach key $keywords {
			if {[lsearch -inline $line $key*] != ""} {
				set kw $key
			}
		}
			if {$kw != ""} {
				if {$kw eq "MAP"} {
					set node [${:doc} createElement Map]
					${:doc} appendChild $node
					set :stack [lappend :stack $node]
				} elseif {$kw eq "NAME" || $kw eq "STATUS" || $kw eq "TYPE"} {
					: -local attr [string tolower $kw] [lindex $line 1]
				} elseif {$kw eq "LAYER" || $kw eq "CLASS" || $kw eq "OUTPUTFORMAT" || $kw eq "PROJECTION" || $kw eq "LEGEND" || $kw eq "LABEL" || $kw eq "QUERYMAP" || $kw eq "SCALEBAR" || $kw eq "WEB" || $kw eq "METADATA"} { ; #NODES WITH END
					set work_node [lindex ${:stack} end]
					set node [${:doc} createElement [string tolower $kw 1 end]]
					$work_node appendChild $node
					set :stack [lappend :stack $node]
				} elseif {$kw eq "STYLE"} {
					set style_data [lindex $line 1]
					if {$style_data eq ""} {
						set work_node [lindex ${:stack} end]
						set node [${:doc} createElement [string tolower $kw 1 end]]
						$work_node appendChild $node
						set :stack [lappend :stack $node]
					} else {
						: -local add_key_val [string tolower $kw] $style_data
					}
				} elseif {$kw eq "DATA" || $kw eq "EXTENT" || $kw eq "ANGLE" || $kw eq "IMAGETYPE" || $kw eq "SHAPEPATH"} {
					: -local add_key_val [string tolower $kw] [lrange $line 1 end]
				} elseif {$kw eq "SIZE" || $kw eq "KEYSIZE" || $kw eq "KEYSPACING" || $kw eq "OFFSET" || $kw eq "SHADOWSIZE" || $kw eq "INTERVALS"} { ;# VALUES WITH 2 ATTR
					set vals [lrange $line 1 end]
					if {[llength $vals] == 2} {
						: -local add_key_attr [string tolower $kw] [dict create x [lindex $vals 0] y [lindex $vals 1]]
					} else {
						: -local add_key_val [string tolower $kw] [lrange $line 1 end]
					}
				} elseif {$kw eq "IMAGECOLOR" || $kw eq "COLOR" || $kw eq "OUTLINECOLOR" } { ;# COLOR RELATED VALUES WITH # ATTR
					set vals [lrange $line 1 end]
					: -local add_key_attr [string tolower $kw] [dict create red [lindex $vals 0] green [lindex $vals 1] blue [lindex $vals 2]]
				} elseif {$kw eq "END"} {
					set :stack [lreplace ${:stack} end end]
				} else {
					: -local add_key_val [string tolower $kw] [lindex [lrange $line 1 end] 0]
				}
			} else {
				set work_node [lindex ${:stack} end]
				if {[$work_node nodeName] eq "Projection"} {
					set data "\n\t[lindex $line 0]\n"
					set tnode [${:doc} createTextNode $data]
					$work_node appendChild $tnode
				}
			}
	}
	
	:private method "add_key_val" {key value} {
		set work_node [lindex ${:stack} end]
		set node [${:doc} createElement $key]
		$node appendChild [${:doc} createTextNode $value]
		$work_node appendChild $node
	}
	
	:private method "add_key_attr" {key attrd} {
		set work_node [lindex ${:stack} end]
		set node [${:doc} createElement $key]
		foreach attr [dict keys $attrd] attr_val [dict values $attrd] {
			$node setAttribute $attr $attr_val
		}
		$work_node appendChild $node
	}
	
	:private method "attr" {attr val} {
		set work_node [lindex ${:stack} end]
		$work_node setAttribute $attr "$val"
	}
	
	:public method get {tag} {
		set result ""
		set nodes [${:doc} getElementsByTagName $tag]
		foreach node $nodes {
			# puts "$node --> [$node data]"
			# set children [$node childNodes]
			# puts "Children: [llength $children]"
			# if {[$child nodeType] eq "TEXT_NODE"} {
				# lappend result [$child nodeValue]
			# }
			lappend result [$node asList]
		}
		return $result
	}

	:public method xml2map {} {
	
	}
	
	:public method as {{type xml}} {
		if {$type eq "xml"} {
			return [${:doc} asXML -xmlDeclaration 1 -encString UTF-8]
		} elseif {$type eq "html"} {
			return [${:doc} asHTML]
		} elseif {$type eq "text"} {
			return [${:doc} asText]
		} elseif {$type eq "json"} {
			return [${:doc} asJSON -indent 1]
		}
	}

}

Mapfile create map -name ./test_data/test_mapfile.map